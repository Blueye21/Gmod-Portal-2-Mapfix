--ispaused()
--IsPlayingBack()
--EstimateLength()

--debug stuff
SceneTable = {}
	SceneTable["PreHub01Chamber01Entry01"] = {postdelay=0.5,next="PreHub01Chamber01Entry02",char="announcer",predelay=0.25}

lastthink = CurTime()
startBlock = 0

--Queue of scenes started with GladosPlayVcd()
scenequeue = {}
firedfromqueue = false

--Map Name
curMapName = game.GetMap()

--PitchShifting stuff
pitchShifting = false
pitchShiftLastThink = CurTime()
pitchShiftInterval = 1.0
pitchShiftValue = 1.0
pitchOverride = nil

--State Flags
stateSlowFieldTraining = false


--jailbreak specific stuff
if curMapName == "sp_sabotage_jailbreak_01" or curMapName == "sp_sabotage_jailbreak" or curMapName == "sp_a2_bts1" then
	jailbreakpos = 0
end


--sp_catapult_fling_sphere_peek specific stuff
if curMapName == "sp_a2_sphere_peek" then
	peekctr = 0
end


--Dings
-- sceneDingOn  = CreateSceneEntity("scenes/npc/glados_manual/ding_on.vcd")
-- sceneDingOff = CreateSceneEntity("scenes/npc/glados_manual/ding_off.vcd")


--Include the autogenerated scene table
include("scenetable_common.lua")

--Include the manual scene table
include("glados_scenetable_include_manual.lua")

--include the manual scene table for act 3
--DoIncludeScript( "choreo/glados_scenetable_include_manual_act3", self.GetScriptScope() )

--include the manual scene table for act 3
--DoIncludeScript( "choreo/glados_scenetable_include_manual_cave", self.GetScriptScope() )

--include the manual scene table for act 4
--DoIncludeScript( "choreo/glados_scenetable_include_manual_act4", self.GetScriptScope() )

function Precache()
    if string.lower(curMapName) == "sp_a4_tb_trust_drop" then
        self:PrecacheSoundScript("World.WheatleyZap")
    end

    if string.lower(curMapName) == "sp_a1_wakeup" then
        self:PrecacheSoundScript("World.HackBuzzer")
    end

    if string.lower(curMapName) == "sp_a3_speed_ramp" then
        self:PrecacheSoundScript("World.WheatleyZap")
        self:PrecacheSoundScript("World.GladosPotatoZap")
    end

    if string.lower(curMapName) == "sp_a3_transition01" then
        self:PrecacheSoundScript("World.GladosPotatoZap")
    end
end

-- OnPostSpawn - this is all the initial setup stuff
function OnPostSpawn()
    local i = 0

    -- Assign a unique id to each scene entity (uses SetTeam because that's the only thing available)
    for _, val in pairs(SceneTable) do
        i = i + 1
        val.vcd:ValidateScriptScope()
        val.vcd:SetTeam(i)
        val.index = i
    end

    -- Initialize the deferred scene queue
    QueueInitialize()
    PuzzlePreStart()

    -- Map-specific spawn stuff
    if curMapName == "sp_a1_wakeup" then
        EntFire("@glados", "runscriptcode", "sp_a1_wakeup_start_map()", 1.0)
    end
end



--Passed the unique team id associated with a scene entity defined in SceneTable, this function returns the correct SceneTable index for that entry
--ex: SceneTableInst = SceneTable[findIndex(team)]
function findIndex(team)
    for idx, val in pairs(SceneTable) do
        if val.index == team then
            return idx
        end
    end
    return nil
end

--Passed the unique team id associated with a scene entity defined in SceneTable, this function returns the scene instance that originally fired it.
--Unfortunately, if multiple scene instances fire the same vcd, this isn't reliable. Hopefully we can either a) fix that 
--or b) not have multiple scene instances use the same vcd (which is currently the case as of 07/19/2010 - efw)
function FindSceneInstanceByTeam(team)
    local inst = nil

    for idx, val in pairs(scenequeue) do
        for idx2, val2 in pairs(val.waitFiredVcds) do
            if val2 == team then
                inst = val
                break -- Exit the inner loop once found
            end
        end
        if inst then
            break -- Exit the outer loop once found
        end
    end

    return inst
end


function SceneCanceled()
end

--If a vcd is tagged to "exit early" (by setting postdelay < 0), this event fires rather than PlayNextScene() when the vcd finishes.
--SkipOnCompletion() has all the functionality of PlayNextScene(), except it doesn't actually play the next scene, because the next scene presumably
--already started playing when the vcd exited early.
--SkipOnCompletion does, however, evaluate the vcd's SceneTable entry to see if any EntFires need to happen.
function SkipOnCompletion()
    print("========SKIPONCOMPLETION CALLING ENTITY: " .. findIndex(owninginstance:GetTeam()) .. " : TIME " .. CurTime())
    
    local team = owninginstance:GetTeam()
    local inst = FindSceneInstanceByTeam(team)
    
    if inst != nil then
        inst.deleteFiredVcd(team)
        inst.waitVcdCurrent = findIndex(team)
        
        -- Are there any EntFires associated with this vcd?
        if inst.waitVcdCurrent != nil then
            if SceneTable[inst.waitVcdCurrent] and SceneTable[inst.waitVcdCurrent].fires then
                for idx, val in pairs(SceneTable[inst.waitVcdCurrent].fires) do
                    if not val.fireatstart then
                        print(">>>>>>ENT FIRE AT (SKIPCOMPLETION) END: " .. val.entity .. ":" .. val.input)
                        EntFire(val.entity, val.input, val.parameter, val.delay)
                    end
                end
            end
        end
    end
end	


function PlayNextScene()
    local team = owninginstance:GetTeam()
    local inst = FindSceneInstanceByTeam(team)
    
    if inst ~= nil then
        print("========PLAYNEXTSCENE CALLING ENTITY: " .. findIndex(owninginstance:GetTeam()) .. " : TIME " .. CurTime())
        inst:deleteFiredVcd(team)
        inst.waitVcdCurrent = findIndex(team)
        PlayNextSceneInternal(inst)
    else
        print("========PLAYNEXTSCENE CALLING ENTITY NO LONGER EXISTS: CHECKING QUEUE...")
        QueueCheck()
    end
end



function PlayNextSceneInternal(inst)
    -- inst = just completed scene
    local i = 0
    local tmp = 0

    -- Set the ducking back to the default value
    SendToConsole("snd_ducktovolume 0.55")
    
    -- Are there any "fire at the end" triggers associated with the just completed?
    if inst.waitVcdCurrent then
        if SceneTable[inst.waitVcdCurrent] and SceneTable[inst.waitVcdCurrent].fires then
            for idx, val in pairs(SceneTable[inst.waitVcdCurrent].fires) do
                if not val.fireatstart then
                    print(">>>>>> ENT FIRE AT END: " .. val.entity .. ":" .. val.input)
                    EntFire(val.entity, val.input, val.parameter, val.delay)
                end
            end
        end
    end
    
    -- If the vcd that's ending is part of a nag cycle, check to see if there are any queued scenes
    -- for the primary nag character. If so, abandon the nag and start the queued scene.
    if inst.isNag then
        if QueueLen(inst.currentCharacter) > 0 then
            print("======== ABANDONING NAG CYCLE TO PLAY QUEUED SCENE")
            scenequeue_DeleteScene(inst.index)
            QueueCheck()
            return
        end
    end
    
    -- Is there another vcd in the scene chain?
    if inst.waitNext ~= nil then
        print("===== There is a next scene: " .. inst.waitNext)
        if inst.waitLength == nil then
            i = i + 1
            print("=================== Ready to play: " .. i)
            GladosPlayVcd(inst)
        else
            inst.waitStartTime = CurTime()
            inst.waiting = 1
        end
    else
        print("===== No next scene!")
        -- Remove the instance from the scene list
        scenequeue_DeleteScene(inst.index)
        -- The current scene is over. Check to see if there are any queued scenes.
        if QueueCheck() then
            return
        end
        -- Do the ding if nothing's queued and the previous scene requires a ding
        if not inst.waitNoDingOff then
            EntFireByHandle(sceneDingOff, "Start", "", 0.1, nil, nil)
        end
    end
end


--Think function
function GladosThink()
    -- Put debug stuff here!
    
    -- Is GLaDOS gibbering?
    -- if glados_gibbering then
        -- sp_sabotage_glados_gibberish()
    -- end
    
    -- Are we PitchShifting?
    if pitchShifting then
        if (CurTime() - pitchShiftLastThink > pitchShiftInterval) then
            local curscene = self:GetCurrentScene()
            if curscene ~= nil then
                local shiftAmount = math.Rand(-0.10, 0.10)
                if shiftAmount < 0.00 then
                    shiftAmount = shiftAmount * 1.5
                end
                pitchShiftValue = pitchShiftValue + shiftAmount
                if pitchShiftValue <= 0.0 or pitchShiftValue >= 1.7 then
                    pitchShiftValue = pitchShiftValue - (shiftAmount * 2)
                end
                -- Assuming curscene is an entity
                EntFireByHandle(curscene, "PitchShift", tostring(pitchShiftValue), 0, nil, nil)
                pitchShiftInterval = math.Rand(0.1, 0.2)
            end
            -- Set Lastthink
            pitchShiftLastThink = CurTime()
        end
    end
    
    -- Scan the list of currently playing scenes
    for idx, val in pairs(scenequeue) do
        -- Check if the current vcd is scheduled to exit early
        if val.waitPreDelayed then
            if CurTime() >= val.waitDelayingUntil then
                print("******* LAUNCHING PREDELAYED SCENE")
                GladosPlayVcd(val)
            end
        end
        if val.waitExitingEarly then
            if CurTime() - val.waitExitingEarlyStartTime >= val.waitExitingEarlyThreshold then
                local team
                val.waitExitingEarly = false
                local curscene = characterCurscene(val.currentCharacter)
                if curscene ~= nil then
                    curscene:ValidateScriptScope()
                    curscene:GetScriptScope().SkipOnCompletion = SkipOnCompletion:Bind(self)
                    curscene:DisconnectOutput("OnCompletion", "PlayNextScene")
                    curscene:DisconnectOutput("OnCompletion", "SkipOnCompletion")
                    curscene:ConnectOutput("OnCompletion", "SkipOnCompletion")
                    team = curscene:GetTeam()
                    val.waitVcdCurrent = findIndex(team)
                end
                print("==== Scene " .. val.index .. " EXITING EARLY")
                PlayNextSceneInternal(val)
                return
            end
        end
    end
    
    -- Check the deferred scene queue
    local tmp = QueueThink()
    -- Is a queued scene ready to fire?
    if tmp ~= nil then
        print("=========== FORCING QUEUED SCENE: " .. tmp)
        GladosPlayVcd(tmp, true)
        return
    end

    for idx, val in pairs(scenequeue) do
        -- Are we waiting to play another vcd?
        if val.waiting == 1 then
            if CurTime() - val.waitStartTime >= val.waitLength then
                val.waiting = 0
                GladosPlayVcd(val)
            end
        end
    end
end


function GladosPlayVcd(arg, IgnoreQueue, caller)
    local dingon = false
    local inst
    local fromqueue = firedfromqueue
    firedfromqueue = false

    -- Handling if arg is an instance
    if type(arg) == "userdata" then  -- "instance" isn't a valid Lua type, so assuming "userdata" for instances
        if arg.waitPreDelayed then
            inst = arg
            arg = inst.waitPreDelayedEntry
        else
            inst = arg
            arg = inst.waitNext
        end
    else
        local sceneStart = 0
        if type(arg) == "number" then  -- "integer" in Lua is just "number"
            if arg == 407 or arg == 43 then
                return
            end
            sceneStart = arg
            arg = SceneTableLookup[arg]
        else
            sceneStart = 0
        end
        if SceneTable[arg].skipifbusy then
            if characterCurscene(SceneTable[arg].char) then
                return
            end
        end

        -- Check queue
        if SceneTable[arg].queue then
            if IgnoreQueue == nil then
                if SceneTable[arg].queuecharacter then
                    if characterCurscene(SceneTable[arg].queuecharacter) then
                        QueueAdd(arg)
                        return
                    end
                else
                    if characterCurscene(SceneTable[arg].char) then
                        QueueAdd(arg)
                        return
                    end
                end
            end
        end

        -- Add scene to queue
        if scenequeue_AddScene(arg, SceneTable[arg].char) == nil then
            return
        end

        inst = scenequeue[arg]
        inst.waitSceneStart = sceneStart

        -- If idle, initialize nags
        if SceneTable[arg].idle then
            nags_init(inst, arg)
        end

        dingon = true
        pitchShifting = false
        if SceneTable[arg].noDingOff then
            inst.waitNoDingOff = true
        else
            inst.waitNoDingOff = false
        end
        if SceneTable[arg].noDingOn then
            inst.waitNoDingOn = true
        else
            inst.waitNoDingOn = false
        end
    end

    -- Handle pre-delay logic
    local preDelay = 0.00
    if not inst.waitPreDelayed then
        preDelay = EvaluateTimeKey("predelay", SceneTable[arg])

        if fromqueue and SceneTable[arg].queuepredelay then
            preDelay = EvaluateTimeKey("queuepredelay", SceneTable[arg])
        end

        if preDelay > 0.00 then
            inst.waitPreDelayed = true
            inst.waitDelayingUntil = CurTime() + preDelay
            inst.waitPreDelayedEntry = arg
            print("======= " .. arg .. " PREDELAYED FOR " .. preDelay .. " SECONDS")
            return
        end
    else
        inst.waitPreDelayed = false
        inst.waitPreDelayedEntry = nil
    end

    -- Handling nags
    if inst.isNag then
        if not inst.naginchain then
            arg = nags_fetch(inst)
        end
        if arg == nil then
            scenequeue_DeleteScene(inst.index)
            return
        end
    end

    -- Adjusting volume
    RunConsoleCommand("snd_ducktovolume", "0.2")
    if arg ~= nil then
        local ltalkover
        ltalkover = SceneTable[arg].talkover

        if not ltalkover then
            GladosAllCharactersStopScene()
        else
            GladosCharacterStopScene(SceneTable[arg].char)
        end

        if dingon and not inst.waitNoDingOn then
            EntFireByHandle(sceneDingOn, "Start", "", 0.00, nil, nil)
        end

        inst.currentCharacter = SceneTable[arg].char

        SceneTable[arg].vcd:ValidateScriptScope()
        SceneTable[arg].vcd:GetScriptScope().PlayNextScene = PlayNextScene
        SceneTable[arg].vcd:DisconnectOutput("OnCompletion", "PlayNextScene")
        SceneTable[arg].vcd:ConnectOutput("OnCompletion", "PlayNextScene")
        SceneTable[arg].vcd:ConnectOutput("OnCanceled", "SceneCanceled")

        -- Handle caller target
        if caller ~= nil then
            if type(caller) == "string" then
                EntFireByHandle(SceneTable[arg].vcd, "SetTarget1", caller, 0, nil, nil)
            else
                EntFireByHandle(SceneTable[arg].vcd, "SetTarget1", caller:GetName(), 0, nil, nil)
            end
        end

        if SceneTable[arg].settarget1 then
            EntFireByHandle(SceneTable[arg].vcd, "SetTarget1", SceneTable[arg].settarget1, 0, nil, nil)
        end

        inst.waitVcdTeam = SceneTable[arg].index
        inst.waitVcdCurrent = arg

        inst.addFiredVcd(SceneTable[arg].index)

        -- Handle "Ding On" sound
        if dingon and not inst.waitNoDingOn then
            EntFireByHandle(SceneTable[arg].vcd, "Start", "", 0.00 + 0.18, nil, nil)
        else
            EntFireByHandle(SceneTable[arg].vcd, "Start", "", 0.00, nil, nil)
        end

        -- Fire events at the start
        if SceneTable[arg].fires then
            for _, val in pairs(SceneTable[arg].fires) do
                if val.fireatstart then
                    print(">>>>>>ENT FIRE AT START: " .. val.entity .. ":" .. val.input)
                    EntFire(val.entity, val.input, val.parameter, val.delay)
                end
            end
        end

        -- Handle special cases
        if SceneTable[arg].special then
            if SceneTable[arg].special == 1 then
                pitchShifting = true
            elseif SceneTable[arg].special == 2 then
                if pitchOverride == nil then
                    EntFireByHandle(SceneTable[arg].vcd, "PitchShift", "2.5", 0, nil, nil)
                end
            elseif SceneTable[arg].special == 3 then
                EntFireByHandle(SceneTable[arg].vcd, "PitchShift", "0.9", 0, nil, nil)
            end
            if pitchOverride ~= nil then
                EntFireByHandle(SceneTable[arg].vcd, "PitchShift", tostring(pitchOverride), 0, nil, nil)
            end
        end

        -- Handle post delay and next scene
        if SceneTable[arg].next ~= nil or inst.isNag then
            local pdelay = EvaluateTimeKey("postdelay", SceneTable[arg])

            -- If it's a nag, use min/max defined in the first entry in the scene
            if inst.isNag then
                pdelay = math.random(inst.nagminsecs, inst.nagmaxsecs)
            end

            if pdelay < 0.00 then
                if inst.isNag then
                    if SceneTable[arg].next ~= nil then
                        inst.waitNext = SceneTable[arg].next
                        inst.naginchain = true
                    else
                        inst.waitNext = arg
                        inst.naginchain = false
                    end
                else
                    inst.waitNext = SceneTable[arg].next
                    inst.waitExitingEarly = true
                    inst.waitLength = nil
                    inst.waitExitingEarlyStartTime = CurTime()
                    if inst.naginchain then
                        pdelay = EvaluateTimeKey("postdelay", SceneTable[arg])
                    end
                    inst.waitExitingEarlyThreshold = pdelay * -1
                end
            else
                inst.waitExitingEarly = false
            end
            inst.waitLength = pdelay
        else
            inst.waitNext = nil
            print("===================SCENE END")
        end
    end
end

function EvaluateTimeKey(keyname, keytable)
    local ret = nil

    if keytable[keyname] ~= nil then
        local typ = type(keytable[keyname])
        if typ == "table" then
            if #keytable[keyname] ~= 2 then
                print("!!!!!!!!!!!!EVALUATE TIME KEY ERROR: " .. keyname .. " is a table with a length != 2")
                return 0.00
            end
            ret = math.random(keytable[keyname][1], keytable[keyname][2])
        else
            ret = keytable[keyname]
        end
    end
    
    if ret == nil then
        ret = 0.00
    end

    print(">>>>>>>>>EVALUATE TIME KEY: " .. keyname .. " : " .. ret)
    return ret
end



function GladosSetPitch(arg)
    pitchOverride = arg
    local curscene = self:GetCurrentScene()
    
    if curscene ~= nil then
        EntFireByHandle(curscene, "PitchShift", tostring(pitchOverride), 0, nil, nil)
    end
end


function nuke()
    scenequeue = {}
    Queue:clear()
    GladosAllCharactersStopScene()
    StopAllCaveSpeakers()
end

--Checks each cave speaker actor to see if it's playing a vcd and stops it if it is.
function StopAllCaveSpeakers()
    local caveactors = {
        "@cave_exit_lift",
        "cave_a3_03_dummy",
        "cave_a3_03_dummy2",
        "cave_a3_03_dummy3",
        "cave_a3_03_exit",
        "cave_a3_03_lift_shaft",
        "cave_a3_03_waiting_room",
        "cave_a3_jump_intro_entrance",
        "cave_a3_jump_intro_interchamber",
        "cave_a3_jump_intro_second_chamber",
        "cave_a3_transition01_dummy",
        "cave_a3_transition01_dummy2",
        "cave_a3_transition01_dummy3",
        "cave_bomb_flings_chamber",
        "cave_bomb_flings_entrance",
        "cave_crazy_box_2nd_chamber",
        "cave_crazy_box_dummy_chamber",
        "cave_crazy_box_entrance",
        "cave_portal_intro_entrance",
        "cave_portal_intro_exit",
        "cave_portal_intro_office",
        "cave_portal_intro_whitepaint",
        "cave_speed_flings_entrance",
        "cave_speed_ramp_entrance",
        "cave_speed_ramp_inter_chamber",
        "cave_transition01_dummy_exit",
        "cave_transition01_welcome"
    }

    for _, val in ipairs(caveactors) do
        local ent = nil
        ent = ents.FindByName(val)[1]
        if ent then
            local sc = ent:GetCurrentScene()
            if sc then
                -- Use a proper method to stop the scene here
                -- You might need to use `sc:Fire("Cancel")` or something specific in Garry's Mod to cancel
                sc:Fire("Cancel", "", 0)
            end
        end
    end
end


--Stops a scene for all characters
function GladosAllCharactersStopScene()
	GladosCharacterStopScene("glados")
	GladosCharacterStopScene("wheatley")
	GladosCharacterStopScene("cave_body")
	GladosCharacterStopScene("core01")
	GladosCharacterStopScene("core02")
	GladosCharacterStopScene("core03")
end

function characterCurscene(arg)
    local ret, ent = nil, nil
    
    if arg == "bossannouncer" then
        ent = Entities:FindByName(ent, "@actor_announcer")
    elseif arg == "announcerglados" then
        ent = Entities:FindByName(ent, "@glados")
    elseif arg == "glados" or arg == "@glados" then
        ent = Entities:FindByName(ent, "@glados")
    elseif arg == "cave" or arg == "@cave" then
        ent = Entities:FindByName(ent, "@cave")
    elseif arg == "@sphere" or arg == "wheatley" or arg == "sphere" then
        ent = Entities:FindByName(ent, "@sphere")
    elseif arg == "core01" or arg == "@core01" then
        ent = Entities:FindByName(ent, "@core01")
    elseif arg == "core02" or arg == "@core02" then
        ent = Entities:FindByName(ent, "@core02")
    elseif arg == "core03" or arg == "@core03" then
        ent = Entities:FindByName(ent, "@core03")
    elseif arg == "cave_body" or arg == "cavebody" then
        ent = Entities:FindByName(ent, "@cave_body")
    elseif arg == "conveyor_turret" then
        ent = Entities:FindByName(ent, "conveyor_turret_body")
    end

    if ent then
        print("&&&&&&FOUND ENTITY: " .. arg)
        ret = ent:GetCurrentScene()
    end

    return ret
end

--Stops a scene for a particular character
function GladosCharacterStopScene(arg)
    local ent = nil
    local curscene = characterCurscene(arg)
    
    if curscene ~= nil then
        print("&&&&&&STOP SCENE: " .. arg .. " FOUND SCENE TO DELETE!!!!!!!!!")
        EntFireByHandle(curscene, "Cancel", "", 0, nil, nil)
    else
        print("&&&&&&STOP SCENE: NO SCENE TO DELETE FOR " .. arg)
    end
end

--Turns off current Glados speech
function GladosStopTalking()
    local curscene = self:GetCurrentScene()
    pitchOverride = nil
    waitNext = nil
    waitLength = nil

    if curscene ~= nil then
        EntFireByHandle(curscene, "Cancel", "", 0, nil, nil)
    end
end

--Turns off current Glados speech if the scene # passed as arg is currently playing
function GladosStopScene(arg)
    if waitSceneStart == arg then
        local curscene = self:GetCurrentScene()
        pitchOverride = nil
        waiting = 0
        waitNext = nil
        waitLength = nil

        if curscene ~= nil then
            EntFireByHandle(curscene, "Cancel", "", 0, nil, nil)
        end
    end
end

--Slowfield functions
function GladosEndSlowFieldTraining()
    stateSlowFieldTraining = false
    GladosStopTalking()
end

function GladosStartSlowFieldTraining()
    stateSlowFieldTraining = true
    GladosPlayVcd(40)
end

function GladosSlowFieldOn()
    if stateSlowFieldTraining then
        GladosPlayVcd(41)
    end
end

function GladosSlowFieldOff()
	if stateSlowFieldTraining then
		GladosPlayVcd(40)
	end
end
--End of Slowfield functions

--Special Chamber Processing
function GladosRelaxationVaultPowerUp()
	EntFire("open_portal_relay","Trigger","", 0.00)
end

------------------------------------------------------------------------------------------------------------------
-- Automated dialog lookup
------------------------------------------------------------------------------------------------------------------

function MapNameConversion(orgname)
    if MapBspConversion[orgname] ~= nil then
        return MapBspConversion[orgname]
    else
        return orgname
    end
end


GladosDialog = {
    { map = "sp_a1_intro2", prestart = "PreHub01PortalCarouselEntry01", completed = "PreHub01PortalCarouselSuccess01" },
    { map = "sp_a1_intro3", prestart = "sp_intro_03Start01", completed = "sp_intro_03MindTheGapFinish01" },
    { map = "sp_a1_intro4", start = "PreHub01BoxDropperEntry01", completed = "sp_a1_intro4End01" },
    --{ map = "sp_a1_intro5", start = "PreHub01DualButtonOnePortalEntry01", completed = "PreHub01DualButtonOnePortalSuccessB01" },
    { map = "sp_a1_intro5", start = "sp_a1_intro5Start01", completed = "PreHub01DualButtonOnePortalSuccessB01" },
    { map = "sp_a1_intro6", start = "sp_a1_intro6Start01", completed = "sp_a1_intro6End01" },
    { map = "sp_a1_intro7", prestart = "sp_a1_intro7Start01" },
    --{ map = "sp_incinerator_01", exitstarted = "sp_incinerator_01Elevator01" },
    { map = "sp_laser_redirect_intro", start = "sp_laser_redirect_introStart01", completed = "sp_laser_redirect_introEnd01" },
    { map = "sp_laser_stairs", start = "sp_laser_stairsStart01", completed = "sp_laser_stairsEnd01" },
    { map = "sp_laser_dual_lasers", prestart = "sp_laser_dual_lasersStart01", completed = "sp_laser_dual_lasersEnd01" },
    { map = "sp_laser_over_goo", start = "sp_laser_over_gooStart01", completed = "sp_laser_over_gooEnd01" },
    { map = "sp_catapult_intro", completed = "sp_catapult_introEnd01" },
    { map = "sp_trust_fling", prestart = "sp_trust_flingStart01", completed = "sp_trust_flingEnd01" },
    { map = "sp_a2_pit_flings", prestart = "sp_a2_pit_flingsStart01", completed = "sp_a2_pit_flingsCubeSmuggleEnding01" },
    { map = "sp_a2_fizzler_intro", start = "sp_a2_fizzler_introStart01" },
    { map = "sp_catapult_fling_sphere_peek", completed = "sp_catapult_fling_sphere_peekEnd01" },
    { map = "sp_a2_ricochet", prestart = "sp_a2_ricochetStart01", completed = "sp_a2_ricochetEnd01" },
    { map = "sp_bridge_intro", completed = "sp_bridge_introEnd01" },
    { map = "sp_bridge_the_gap", prestart = "sp_bridge_the_gapStart01", completed = "sp_bridge_the_gapEnd01" },
    { map = "sp_turret_training_advanced", prestart = "sp_turret_training_advancedStart01" },
    { map = "sp_laser_relays", prestart = "sp_laser_relaysStart01", completed = "sp_laser_relaysEnd01" },
    { map = "sp_a2_turret_blocker", prestart = "sp_turret_blocker_introStart01", completed = "sp_turret_blocker_introEnd01" },
    { map = "sp_laser_vs_turret_intro", prestart = "sp_laser_vs_turret_introStart01", completed = "sp_laser_vs_turret_introEnd01" },
    { map = "sp_a2_pull_the_rug", prestart = "sp_a2_pull_the_rugStart01", completed = "sp_a2_pull_the_rugEnd01" },
    --RING AROUND THE TURRETS NO LONGER IN THE TRACK
    --{ map = "sp_ring_around_the_turrets", completed = "sp_ring_around_the_turretsEnd01" },
    { map = "sp_column_blocker", completed = "sp_column_blockerEnd01" },
    { map = "sp_a2_laser_chaining", prestart = "sp_a2_laser_chainingStart01", completed = "sp_a2_laser_chainingEnd01" },
    --Turret Tower no longer in track
    --{ map = "sp_turret_tower", prestart = "sp_turret_towerStart01", completed = "sp_turret_towerEnd01" },
    { map = "sp_a2_triple_laser", start = "sp_a2_triple_laserStart01", completed = "sp_a2_triple_laserEnd01" },
    { map = "sp_sabotage_jailbreak", prestart = "sp_sabotage_jailbreakStart01" },
    { map = "sp_a3_speed_ramp", prestart = "-3150_01" },
    { map = "sp_a4_finale3", prestart = "-4849_01" },
}

--Generic glados dialog functions.
--PuzzleStart fires automatically as the player moves out of the level transition area
function PuzzleStart()
    print("===============In Puzzle Start " .. game.GetMap())

    local mpco
    for index, level in ipairs(GladosDialog) do
        mpco = MapNameConversion(level.map)
        if (level.map == game.GetMap() or mpco == game.GetMap()) and level.start then
            print("===============PuzzleStart: playing scene " .. level.start)
            GladosPlayVcd(level.start)
        end
    end
end

--PuzzlePreStart fires just after the level load
function PuzzlePreStart()
    print("===============In Puzzle PreStart")
    local mpco
    for index, level in ipairs(GladosDialog) do
        -- MapNameConversion is a placeholder, assuming it’s a custom function
        mpco = MapNameConversion(level.map)
        
        if (level.map == game.GetMap() or mpco == game.GetMap()) and level.prestart then
            print("===============PuzzlePreStart: playing scene " .. level.prestart)
            GladosPlayVcd(level.prestart)
        end
    end
end

didLeftElevatorChamber = false

function LeftElevatorChamber()
    if not didLeftElevatorChamber then
        didLeftElevatorChamber = true
        local mpco

        -- Iterating over GladosDialog using pairs to properly access key-value pairs
        for _, level in pairs(GladosDialog) do
            mpco = MapNameConversion(level.map)
            
            -- Check if the map matches and contains the leftelevatorchamber field
            if (level.map == game.GetMap() or mpco == game.GetMap()) and level.leftelevatorchamber then
                print("===============LeftElevatorChamber: playing scene " .. level.leftelevatorchamber)
                
                -- Play the corresponding VCD
                RunConsoleCommand("playvcd", level.leftelevatorchamber)
            end
        end
    end
end

--ExitStarted fires when the exit elevator doors close
function ExitStarted()
    print("===============In Puzzle ExitStarted")

    local mpco
    for index, level in ipairs(GladosDialog) do
        mpco = MapNameConversion(level.map)
        if (level.map == game.GetMap() or mpco == game.GetMap()) and level.exitstarted then
            print("===============ExitStarted: playing scene " .. level.exitstarted)
            GladosPlayVcd(level.exitstarted)
        end
    end
end

--PuzzleCompleted fires when the glados exit speech is supposed to trigger. It isn't fired automatically from an instance.
--It needs to fire from a trigger in the map
function PuzzleCompleted()
    local mpco

    -- Iterate over the GladosDialog table
    for _, level in pairs(GladosDialog) do
        mpco = MapNameConversion(level.map)

        -- Check if the current map matches and if a "completed" scene exists
        if (level.map == game.GetMap() or mpco == game.GetMap()) and level.completed then
            print("===============PuzzleCompleted: playing scene " .. level.completed)

            -- Play the corresponding VCD
            GladosPlayVcd(level.completed)
        end
    end
end

----------------------------------------------------------------------------------------------------------------
--Queue Functions
--	-This is the queue of scenes delayed by another scene
----------------------------------------------------------------------------------------------------------------

Queue = {}

--Initialize the queue
function QueueInitialize()
	Queue.clear()
end

--Add a scene to the queue
--Queue table structure:
--	item 						= index in SceneTable (ie: SceneTable[Queue[index].item])
--	added						= time added to queue
--	queueforcesecs	= (from SceneTable) force item to play after queueforcesecs seconds in queue
--	queuetimeout		= (from SceneTable) delete item if it sits in queue for queuetimeout seconds
--	queuepredelay		= (from SceneTable) wait queuepredelay seconds to fire the scene if it sat in the queue for any amount of time
function QueueAdd(arg)
    -- Append the item to the queue with the current time
    table.insert(Queue, { item = arg, added = CurTime() })  -- Use CurTime() for game time

    if SceneTable[arg] then
        local queueItem = Queue[#Queue] -- Access the last item in the Queue

        -- Set queueforcesecs with default value if not present
        if SceneTable[arg].queueforcesecs then
            queueItem.queueforcesecs = SceneTable[arg].queueforcesecs
        else
            queueItem.queueforcesecs = 45.0
        end

        -- Set queuetimeout if present
        if SceneTable[arg].queuetimeout then
            queueItem.queuetimeout = SceneTable[arg].queuetimeout
        end

        -- Set queuepredelay if present
        if SceneTable[arg].queuepredelay then
            queueItem.queuepredelay = SceneTable[arg].queuepredelay
        end
    end
end

--Returns number of items in the queue
function QueueLen(char)
    local i = 0

    -- If no character is provided, return the length of the queue
    if char == nil then
        return #Queue
    else
        -- Iterate through the Queue and count the occurrences of the character
        for _, scene in pairs(Queue) do
            if SceneTable[scene.item].char == char then
                i = i + 1
            end
        end
        return i
    end
end

-- Fetch the next scene in the queue
function QueueGetNext()
    local ret = nil
    local l = QueueLen()

    if l > 0 then
        -- Get the last scene from the queue and remove it
        ret = Queue[l].item
        table.remove(Queue, l)
    end

    return ret
end

-- function QueueDebug()
-- {
--	print("===================  items in queue-> " + Queue.len())
--	foreach (index, scene in Queue)
--	{
--		print("========= queue item "+index+"("+scene.item+"): character "+SceneTable[scene.item].char)
--	}
--}

--General stuff called from GladosThink()
function QueueThink()
    local ret, t, index
    -- If the queue is empty, return nil
    if QueueLen() == 0 then
        return nil
    end

    t = CurTime()  -- Use CurTime() for the current time in Garry's Mod

    -- Check to see if any queued scenes timed out
    for index = QueueLen(), 1, -1 do
        if Queue[index] and Queue[index].queuetimeout then
            if t - Queue[index].added > Queue[index].queuetimeout then
                table.remove(Queue, index)
            end
        end
    end

    -- Check to see if any queued scenes should force fire
    for index, scene in pairs(Queue) do
        if scene.queueforcesecs then
            if t - scene.added > scene.queueforcesecs then
                ret = scene.item
                table.remove(Queue, index)
                return ret
            end
        end
    end

    return nil
end

--Debug testbed function
function QueueTest()
    local a = {}
    
    -- Populate the table with random integers
    for i = 0, 9 do
        table.insert(a, math.random(1, 100))  -- Insert a random number between 1 and 100
        print(">>>>>> " .. i .. " : " .. a[i+1])  -- Lua arrays start at index 1, not 0
    end
    
    -- Remove elements less than 50 from the table
    for i = #a, 1, -1 do
        if a[i] < 50 then
            table.remove(a, i)
        end
    end
    
    -- Print remaining values in the table
    for index, n in ipairs(a) do
        print(">>>>>> " .. index .. " : " .. n)
    end
end

--Delete a single item from the queue
function QueueDeleteItem(item)
    if QueueLen() == 0 then
        return false
    end

    -- Iterate through the Queue to find the item and remove it
    for index, scene in pairs(Queue) do
        if scene.item == item then
            table.remove(Queue, index)
            return true
        end
    end
    return false
end

-- Function to check if there’s a queued scene ready to fire
function QueueCheck()
    local tmp
    if QueueLen() > 0 then
        print("===QUEUE LEN IS " .. QueueLen())  -- Use print() for Garry's Mod debugging
        tmp = QueueGetNext()
        if tmp ~= nil then
            firedfromqueue = true
            GladosPlayVcd(tmp, true)
            -- GladosPlayVcd(tmp) -- Uncomment if needed
            return true
        end
    end
    return false
end

----------------------------------------------------------------------------------------------------------------
--End of Queue Functions
----------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------
--sp_sabotage_jailbreak specific functions 
----------------------------------------------------------------------------------------------------------------

function jailbreak_alert(arg)
	jailbreakpos = arg
end

function jailbreak_whoah_speech()
	if jailbreakpos == 0 then
		GladosPlayVcd(303)
	else
		GladosPlayVcd(302)
	end
end


----------------------------------------------------------------------------------------------------------------
--sp_sabotage_darkness specific functions 
----------------------------------------------------------------------------------------------------------------


function PlayGhostStory()
	GladosPlayVcd(445)
end

function PlaySmellyHumansOne()
	GladosPlayVcd(446)
end

function PlaySmellyHumansTwo()
	GladosPlayVcd(447)
end
 
function PlaySmellyHumansThree()
	GladosPlayVcd(448)
end

function PlaySmellyHumansFour()
	GladosPlayVcd(449)
end


----------------------------------------------------------------------------------------------------------------
--Glados Battle specific functions 
----------------------------------------------------------------------------------------------------------------

glados_gibbering = false
glados_gibbering_start = CurTime()
glados_gibbering_next = 0.00
glados_gibbering_times = {}

glados_gibbering_times[1] = 0.7
glados_gibbering_times[2] = 1.37
glados_gibbering_times[3] = 1.22
glados_gibbering_times[4] = 1.27
glados_gibbering_times[5] = 5.29
glados_gibbering_times[6] = 4.15
glados_gibbering_times[7] = 3.35



if curMapName =="sp_a2_core" then
	sp_a2_core_xfer_left_annex = false
end



function sp_sabotage_glados_start_gibberish()
	--gibberish is off for now
	--glados_gibbering = true
	glados_gibbering_start = CurTime()
	glados_gibbering_next = 0.00
end

function sp_sabotage_glados_stop_gibberish()
	glados_gibbering = false
end

function sp_sabotage_glados_gibberish()
    local i = math.random(1, 7)  -- math.random generates a random number between 1 and 7
    if (CurTime() - glados_gibbering_start > glados_gibbering_next) then  -- CurTime() is used in Garry's Mod for the current time
        -- The scene_playvcd function may not exist by default. If it's a custom function, it should be defined elsewhere
        -- SendToConsole is also a valid way to send console commands, or you could use other methods specific to your environment
        RunConsoleCommand("scene_playvcd", "npc/glados/sp_sabotage_glados_gibberish0" .. i)  -- Sends the scene play command to the console
        glados_gibbering_start = CurTime()
        -- glados_gibbering_next = math.Rand(3.5, 5.0)  -- If you want a random float instead
        glados_gibbering_next = glados_gibbering_times[i]
    end
end



-- ==============================
-- player starts vault trap
-- ==============================
function VaultTrapStart()
	GladosPlayVcd(-50)
end

-- ==============================
-- player begins moving in relaxation vault
-- ==============================
function VaultTrapStartMoving() 
	GladosPlayVcd(-53)
end

-- ==============================
-- turrets are on the ground and begin their scene
-- ==============================
function TurretScene()
	GladosPlayVcd(-700)
end
 
-- ==============================
-- ==============================
function TurretDeathReactionDialog()
	GladosPlayVcd(-57)
	--gladosbattle_pre_05 -- my turrets!
	--gladosbattle_pre_06 -- oh, you were busy back there
	--gladosbattle_pre_17 -- i suppose we could just sit here and glare ... but i have a better idea
end



-- ==============================
-- ==============================
function WheatleyBouncingDownTubeDialog()
	-- play various "ouch.. oof... ow..." lines here
	-- play glados dialog responding to wheatley falling.  "...sigh..."
end


-- ==============================
-- ==============================
function WheatleyLandsInChamberDialog()
	GladosPlayVcd(-61)
	print("==========HELLO!!!!!!!!!!!!!!!!!!!!!")
	--wheatley - gladosbattle_pre01 -- Hello!
	--gladosbattle_pre_09 -- i hate you so much
end

-- ==============================
-- ==============================
function CoreDetectedDialog()
	--announcer - gladosbattle02 -- warning: core corrupted
	--glados - gladosbattle_xfer04 -- that's funny i don't feel corrupted. in fact i feel pretty good
	--announcer - gladosbattle03 -- alternate core detected
	--wheatley pre05  -- ah that's me they're talking about!
	--announcer - gladosbattle03 -- to initiate a core transfer deposit core in receptacle
	--ent_fire "deploy_core_receptacle_relay" trigger -- deploys the core receptacle
	--glados - gladosbattle_xfer05 -- core transfer?
	--glados - gladosbattle_xfer06 -- oh you are kidding me
end


-- ==============================
-- ==============================
function WheatleyCoreSocketed()
	StopWheatleyPluginNag()
	GladosPlayVcd(-71) -- announcer - substitute core accepted.  core, are you willing to start the procedure?
end

-- ==============================
--	called when the player reaches a catapult or enters the room to press stalemate button
-- ==============================
function StalemateAssociateNotSoFast()
	StopWheatleyPluginNag()
	GladosPlayVcd(-84)
end


-- ==============================
-- ==============================
function CoreTransferInitiated()
	-- start the core particle system
	nuke()
	EntFire("glados_shutdown_particles_relay", "trigger", 0, 0 )
	GladosPlayVcd(-88) --Stalemate Resolved. Core Transfer Initiated.
end

-- ==============================
-- ==============================
function WheatleyCoreTransferStart()
	sp_a2_core_xfer_left_annex = true
	--nuke()
	GladosPlayVcd(-4) -- Here I go!
end

function sp_a2_core_leave_annex_nag()
	if not sp_a2_core_xfer_left_annex then
		GladosPlayVcd(-45)
	end
end

-- ==============================
-- ==============================
function PitHandsGrabGladosHead()
	GladosPlayVcd(-89) -- Get your hands off me!
end

-- ==============================
-- ==============================
function PullGladosIntoPit()
	GladosPlayVcd(-90) -- CHELL! STOP THIS! I AM YOUR MOTHER!
end

-- ==============================
-- ==============================
function CoreTransferCompleted()
	GladosPlayVcd(-9)  -- Wow! Check ME out, Partner! .. Look how small you are!
end

-- ==============================
-- ==============================
function PlayerEnteredElevator()
	StopWheatleyElevatorNag()
	CorePlayerInElevator = 1 -- this will prevent the elevator nag from being triggered by subsequent IO
	EntFire("@exit_elevator_music_relay","trigger", 0, 0 )
	GladosPlayVcd(-13) -- I knew it was going to be cool being in charge..
	
	-- delete many of the small_pos arms
	EntFire("small_pos1", "kill", 0, 0 )
	EntFire("small_pos3", "kill", 0, 0 )
	EntFire("small_pos4", "kill", 0, 0 )
	EntFire("small_pos7", "kill", 0, 0 )
	EntFire("small_pos9", "kill", 0, 0 )
	EntFire("small_pos10", "kill", 0, 0 )
end


-- ==============================
-- ==============================
function DialogDuringPotatosManufacture()
	GladosPlayVcd(-33)
end

-- ==============================
-- ==============================
function PotatosPresentation()
	GladosPlayVcd(-34)
end

-- ==============================
-- ==============================
function ElevatorMoronScene()
	GladosPlayVcd(-37)
end

-- ==============================
-- ==============================
function ElevatorConclusion()
	GladosPlayVcd(-44)
end


----------------------------------------------------------------------------------------------------------------
--sp_sabotage_factory functions 
----------------------------------------------------------------------------------------------------------------

function sabotage_factory_WatchTheLine()
	GladosPlayVcd(441)
end

function sabotage_factory_ReachedHackingSpot()
	GladosPlayVcd(442)
end

function sabotage_factory_PlayerReachedWheatley()
	WheatleyStopNag()
	GladosPlayVcd(443)
end

function sabotage_factory_PlayerReachedExitDoor()
	WheatleyStopNag()
	GladosPlayVcd(444)
end


----------------------------------------------------------------------------------------------------------------
--sp_sabotage_factory - Science Fair functions 
----------------------------------------------------------------------------------------------------------------
function ScienceFairGoingTheRightWay()
	GladosPlayVcd( -100 )
end

function ScienceFairBringDaughter()
	GladosPlayVcd( -101 )
end

function JustToReassureYou()
	GladosPlayVcd( -102 )
end

function DefinitelySureThisWay()
	GladosPlayVcd( -103 )
end


----------------------------------------------------------------------------------------------------------------
--sp_catapult_fling_sphere_peek functions 
----------------------------------------------------------------------------------------------------------------

function sp_catapult_fling_sphere_peek()
    if peekctr == 0 then
        GladosPlayVcd(335)
    elseif peekctr == 2 then
        GladosPlayVcd(362)
    elseif peekctr == 4 then
        GladosPlayVcd(363)
    end
    
    peekctr = peekctr + 1
end


----------------------------------------------------------------------------------------------------------------
--New test functions 
----------------------------------------------------------------------------------------------------------------
function GladosTest1(arg)
    for index, scene in ipairs(arg) do
        if scene.item then
            table.remove(arg, index)
        end
    end
end


----------------------------------------------------------------------------------------------------------------
--Scenes List Functions START
--	-This is the list of currently playing scenes
----------------------------------------------------------------------------------------------------------------

scene = {}

function scene:new(a, caller)
    local obj = {}
    setmetatable(obj, self)
    self.__index = self
    
    obj.index = a
    obj.owner = caller
    obj.currentCharacter = ""
    obj.waitSceneStart = 0  -- 1 means we're waiting for the current vcd to finish so we can play the next vcd in the chain
    obj.waiting = 0  
    obj.waitVcdCurrent = nil
    obj.waitStartTime = CurTime()  -- Use CurTime() for time
    obj.waitLength = CurTime()    -- Same for time-related variables
    obj.waitNext = nil 
    obj.waitExitingEarly = false 
    obj.waitExitingEarlyStartTime = CurTime() 
    obj.waitExitingEarlyThreshold = 0.00
    obj.waitDelayingUntil = nil
    obj.waitPreDelayed = false
    obj.waitPreDelayedEntry = nil
    obj.waitNoDingOff = false
    obj.waitNoDingOn = false
    obj.waitVcdTeam = -1
    obj.waitFiredVcds = {}
    obj.nagminsecs = 0
    obj.nagmaxsecs = 0
    obj.nags = {}
    obj.isNag = false
    obj.nagpool = {}
    obj.naglastfetched = nil
    obj.nagrandom = false
    obj.nagrandomonrepeat = false
    obj.nagtimeslistcompleted = 0
    obj.nagrepeat = false
    obj.naginchain = false
    
    return obj
end

-- Method to clear nags
function scene:nagsClear()
    self.naglastfetched = nil
    self.nags = {}
end

-- Method to clear nagpool
function scene:nagpoolClear()
    self.nagpool = {}
end

-- Method to add fired VCD
function scene:addFiredVcd(team)
    table.insert(self.waitFiredVcds, team)
end

-- Method to delete fired VCD
function scene:deleteFiredVcd(team)
    for idx, val in ipairs(self.waitFiredVcds) do
        if val == team then
            table.remove(self.waitFiredVcds, idx)
            break
        end
    end
end

-- Property-like access:
scene.index = 0
scene.owner = nil
scene.currentCharacter = ""
scene.waitSceneStart = 0
scene.waiting = 0
scene.waitVcdCurrent = nil
scene.waitStartTime = 0
scene.waitLength = 0
scene.waitNext = nil
scene.waitExitingEarly = false
scene.waitExitingEarlyStartTime = 0
scene.waitExitingEarlyThreshold = 0.00
scene.waitDelayingUntil = nil
scene.waitPreDelayed = false
scene.waitPreDelayedEntry = nil
scene.waitNoDingOff = false
scene.waitNoDingOn = false
scene.waitFires = {}
scene.waitVcdTeam = -1
scene.waitFiredVcds = {}
scene.isNag = false
scene.nags = {}
scene.nagpool = {}
scene.nagminsecs = 0
scene.nagmaxsecs = 0
scene.naglastfetched = nil
scene.nagrandom = false
scene.nagrandomonrepeat = false
scene.nagtimeslistcompleted = 0
scene.nagrepeat = false
scene.naginchain = false


function scenequeue_AddScene(arg, char)
    local delme = nil
    
    -- Iterate over the scenequeue
    for idx, val in ipairs(scenequeue) do
        if SceneTable[idx].char == char then
            delme = idx
        end
        
        if idx == arg then
            print(">>>>>>>>>>Scene " .. arg .. " is already in the queue")
            return nil
        end
    end
    
    -- If a scene to delete is found, delete it
    if delme ~= nil then
        print(">>>>>>>>>>DELETING SCENE " .. delme)
        scenequeue_DeleteScene(delme)
    end
    
    -- Add new scene
    scenequeue[arg] = scene(arg, this)
    scenequeue_Dump()
    
    return scenequeue[arg]
end

function scenequeue_DeleteScene(arg)
    for idx, val in ipairs(scenequeue) do
        if idx == arg then
            print(">>>>>>>>>>Scene " .. arg .. " deleted!")
            table.remove(scenequeue, idx)  -- Remove the scene from the queue
            return true
        end
    end
    return nil
end

function scenequeue_Dump()
    print(">>>>>>>>>>Scene Dump at " .. CurTime())
    for idx, val in ipairs(scenequeue) do
        print(">>>>>>>>>>Scene " .. idx .. " ADDED at " .. val.waitStartTime .. " Type " .. type(val))
    end
end

----------------------------------------------------------------------------------------------------------------
--Scene Queue Functions END
----------------------------------------------------------------------------------------------------------------

----------------------------------------------------------------------------------------------------------------
--Nag Table Functions START
----------------------------------------------------------------------------------------------------------------

function nags_init(inst, scenetableentry)
    local i = 0
    inst:nagsClear()  -- Call the nagsClear method to reset the nags

    -- Initialize nagminsecs and nagmaxsecs based on SceneTable entry
    if SceneTable[scenetableentry].idleminsecs then
        inst.nagminsecs = SceneTable[scenetableentry].idleminsecs
        
        if SceneTable[scenetableentry].idlemaxsecs then
            inst.nagmaxsecs = SceneTable[scenetableentry].idlemaxsecs
        else
            inst.nagmaxsecs = inst.nagminsecs
        end
    end

    -- Set nag-related flags based on SceneTable entry
    if SceneTable[scenetableentry].idlerandomonrepeat then
        inst.nagrandomonrepeat = true
    end
    
    if SceneTable[scenetableentry].idlerepeat then
        inst.nagrepeat = true
    end

    if SceneTable[scenetableentry].idlerandom then
        inst.nagrandom = true
    end

    -- Get the idlegroup and process scenes with the same idlegroup
    local igroup = SceneTable[scenetableentry].idlegroup
    local oig = 0
    
    for idx, val in ipairs(SceneTable) do
        -- Check for conditions to skip the iteration
        if not val.idlegroup or val.idlegroup ~= igroup or val.idleunder then
            continue
        end
        
        local rar = 101
        local mnum = 0
        
        if val.idlerarity then
            rar = val.idlerarity
        end
        
        if val.idlemaxplays then
            mnum = val.idlemaxplays
        end
        
        if val.idleorderingroup then
            oig = val.idleorderingroup
        else
            oig = 0
        end
        
        -- Add the scene to the nags list
        table.insert(inst.nags, {SceneTableIndex = idx, rarity = rar, maxplays = mnum, totplays = 0, orderingroup = oig})
    end

    -- Sort the nags list based on custom comparator
    table.sort(inst.nags, nag_array_compare)
    
    -- Set flags and create the nag pool
    inst.isNag = true
    inst.nagtimeslistcompleted = 0
    nags_createpool(inst)
end

function nags_createpool(inst)
    inst:nagpoolClear()
    
    local tempa = {}
    
    for idx, val in ipairs(inst.nags) do
        local takeit = false
        
        -- Skip if the total plays exceed max plays
        if val.totplays >= val.maxplays and val.maxplays > 0 then
            -- Use continue logic here instead of goto
            continue
        end
        
        -- Check if the random roll passes based on rarity
        if math.random(1, 100) < val.rarity then
            takeit = true
        end
        
        -- Add to temporary pool if takeit is true
        if takeit then
            table.insert(tempa, val)
        end
    end

    -- If the pool is empty, return
    if #tempa == 0 then
        return
    end

    -- Handle random pool generation
    if inst.nagrandom or (inst.nagrandomonrepeat and inst.nagtimeslistcompleted > 0) then
        -- Ensure no repeats by checking if the last fetched scene is not the same
        if #tempa > 1 and inst.naglastfetched then
            while true do
                local r = math.random(1, #tempa)
                if tempa[r].SceneTableIndex ~= inst.naglastfetched then
                    table.insert(inst.nagpool, tempa[r])
                    table.remove(tempa, r)
                    break
                end
            end
        end
        
        -- Fill the rest of the pool randomly
        while #tempa > 0 do
            local r = math.random(1, #tempa)
            table.insert(inst.nagpool, tempa[r])
            table.remove(tempa, r)
        end
    else
        -- If not random, just append all entries from the temporary pool
        for idx, val in ipairs(tempa) do
            table.insert(inst.nagpool, val)
        end
    end
end

function nags_nagpooldump(inst)
    for idx, val in ipairs(inst.nagpool) do
        print("*********NAG " .. idx .. " : " .. val.SceneTableIndex)
    end
end

function nags_fetch(inst)
    -- If the nagpool is empty
    if #inst.nagpool == 0 then
        if inst.nagrepeat then
            inst.nagtimeslistcompleted = inst.nagtimeslistcompleted + 1
            nags_createpool(inst)
            
            -- If still empty after recreating the pool, return nil
            if #inst.nagpool == 0 then
                return nil
            end
        else
            return nil
        end
    end

    -- Fetch the first item in the pool
    local ret = inst.nagpool[1].SceneTableIndex

    -- Increment the total plays for the corresponding scene
    for idx, val in ipairs(inst.nags) do
        if val.SceneTableIndex == ret then
            val.totplays = val.totplays + 1
            break
        end
    end

    -- Remove the first element from the nagpool
    table.remove(inst.nagpool, 1)
    
    -- Update the last fetched scene
    inst.naglastfetched = ret
    
    return ret
end

function GladosStopNag(arg)
    arg = arg or 0  -- Default argument value is 0 if not provided
    nag_stop("glados", arg)
end

function WheatleyStopNag(arg)
    arg = arg or 0  -- Default argument value is 0 if not provided
    nag_stop("wheatley", arg)
end

function Core01StopNag(arg)
    arg = arg or 0  -- Default argument value is 0 if not provided
    nag_stop("core01", arg)
end

function Core02StopNag(arg)
    arg = arg or 0  -- Default argument value is 0 if not provided
    nag_stop("core02", arg)
end

function Core03StopNag(arg)
    arg = arg or 0  -- Default argument value is 0 if not provided
    nag_stop("core03", arg)
end

function nag_stop(char, stoptype)
    -- Iterate over scenequeue and find a scene with the matching character and isNag flag
    local todel = nil
    for idx, val in ipairs(scenequeue) do
        if val.isNag and val.currentCharacter == char then
            todel = idx
            break
        end
    end
    
    -- If a scene was found, delete it from the scene queue
    if todel then
        scenequeue_DeleteScene(todel)
    end
end

function nag_array_compare(a, b)
    if a.orderingroup > b.orderingroup then
        return 1
    elseif a.orderingroup < b.orderingroup then
        return -1
    end
    return 0
end


----------------------------------------------------------------------------------------------------------------
--Nag Table Functions END
----------------------------------------------------------------------------------------------------------------


function TrustFlingCatapultTurretNoticesPlayer()
	GladosPlayVcd(439, nil, "catapulted_turret")
end

----------------------------------------------------------------------------------------------------------------
--Elevator Stoppage in bridge over goo
----------------------------------------------------------------------------------------------------------------

function sp_a2_laser_over_goo_elevator_stoppage()
	GladosPlayVcd(465)
	-- @trigger_this_to_stop_elevator
	-- @trigger_this_to_start_elevator
end


----------------------------------------------------------------------------------------------------------------
--sp_a1_intro7 functions
----------------------------------------------------------------------------------------------------------------
if curMapName == "sp_a1_intro7" then
	sp_a1_intro7_popped = false
	sp_a1_intro7_camethrough = false
	sp_a1_intro7_pickedup = false
	sp_a1_intro7_pickedupcount = 0
	sp_a1_intro7_pluggedin = false
	sp_a1_intro7_turnedaway = false
	sp_a1_intro7_sayingnotdead = false
	sp_a1_intro7_saidnotdead = false
end

function sp_a1_intro7_HeyUpHere()
	GladosPlayVcd(466)
end

function sp_a1_intro7_YouFoundIt()
	EntFire("spherebot_train_1_chassis_1","MoveToPathNode","spherebot_train_1_path_11",8.5)
	GladosPlayVcd(467)
end

function sp_a1_intro7_PopPortal()
	if not sp_a1_intro7_popped then
		GladosPlayVcd(469)
	end
end


function sp_a1_intro7_PopPortalNag()
	if not sp_a1_intro7_popped then
		GladosPlayVcd(468)
	end
end

function sp_a1_intro7_ComeThroughNag()
	if not sp_a1_intro7_camethrough then
		GladosPlayVcd(470)
	end
end


function sp_a1_intro7_PoppedAPortal()
	EntFire("portal_detector","Disable","",0.0)
	EntFire("@glados","runscriptcode","sp_a1_intro7_ComeThroughNag()",4.0)
	WheatleyStopNag()
	sp_a1_intro7_popped = true
end

function sp_a1_intro7_JumpToOtherSide()
	WheatleyStopNag()
	sp_a1_intro7_camethrough = true
end

function sp_a1_intro7_ManagementRail()
	--WheatleyStopNag()
	GladosPlayVcd(471)
end

function sp_a1_intro7_OnThree()
	GladosPlayVcd(472)
end

function sp_a1_intro7_Impact()
	GladosPlayVcd(473)
end


function sp_a1_intro7_NotDeadStart()
	sp_a1_intro7_sayingnotdead = true
end

function sp_a1_intro7_NotDeadEnd()
	sp_a1_intro7_sayingnotdead = false
	sp_a1_intro7_saidnotdead = true
	if sp_a1_intro7_pickedup then
		nuke()
		GladosPlayVcd(572)
	end
end


function sp_a1_intro7_PickMeUpNag()
	if not sp_a1_intro7_pickedup then
		GladosPlayVcd(474)
	end
end

function sp_a1_intro7_PickUp()
    sp_a1_intro7_pickedup = true
    
    if sp_a1_intro7_pickedupcount == 0 then
        sp_a1_intro7_pickedupcount = sp_a1_intro7_pickedupcount + 1
        
        -- Before the "I'm not dead!" line has started playing
        if not sp_a1_intro7_sayingnotdead and not sp_a1_intro7_saidnotdead then
            nuke()
            GladosPlayVcd(571)
        else
            -- The "I'm not dead!" line finished playing before the pickup happened
            if not (not sp_a1_intro7_saidnotdead and sp_a1_intro7_sayingnotdead) then
                WheatleyStopNag()
                GladosPlayVcd(475)
            end
        end
    elseif sp_a1_intro7_pickedupcount == 1 then
        sp_a1_intro7_pickedupcount = sp_a1_intro7_pickedupcount + 1
        nuke()
        GladosPlayVcd(577)
    end
end

function sp_a1_intro7_PlugMeInNag()
	if not sp_a1_intro7_pluggedin then
		GladosPlayVcd(476)
	end
end

function sp_a1_intro7_NoWatching()
	sp_a1_intro7_pluggedin = true
	WheatleyStopNag()
	GladosPlayVcd(477)
end

function sp_a1_intro7_NoWatchingNag()
	if not sp_a1_intro7_turnedaway then
		GladosPlayVcd(481)
	end
end

function sp_a1_intro7_TurnAroundNow()
	sp_a1_intro7_turnedaway = true
	WheatleyStopNag()
	GladosPlayVcd(478)
end

function sp_a1_intro7_BamSecretPanel()
	sp_a1_intro7_turnedaway = true
	WheatleyStopNag()
	GladosPlayVcd(479)
end

function sp_a1_intro7_GloriousFreedom()
	GladosPlayVcd(480)
end

function sp_a1_intro7_DontLeaveMeNag()
end



----------------------------------------------------------------------------------------------------------------
--sp_a1_wakeup functions
----------------------------------------------------------------------------------------------------------------

if curMapName == "sp_a1_wakeup" then
	sp_a1_wakeup_gantryexpositionover = false
	sp_a1_wakeup_gantryexpositioncounter = 0
	sp_a1_wakeup_humanexpositionover = false
	sp_a1_wakeup_In_Breaker_Room = false
	sp_a1_wakeup_Looked_Down = false
end

function sp_a1_wakeup_start_map()    
	GladosPlayVcd(482)
end

function sp_a1_wakeup_gantry_exposition_end()
	sp_a1_wakeup_gantryexpositionover = true
end

function sp_a1_wakeup_inside_observation()
    if sp_a1_wakeup_gantryexpositionover then
        sp_a1_wakeup_gantryexpositionover = false
        if sp_a1_wakeup_gantryexpositioncounter == 0 then
            sp_a1_wakeup_gantryexpositioncounter = sp_a1_wakeup_gantryexpositioncounter + 1
            GladosPlayVcd(483)
        elseif sp_a1_wakeup_gantryexpositioncounter == 1 then
            sp_a1_wakeup_gantryexpositioncounter = sp_a1_wakeup_gantryexpositioncounter + 1
            GladosPlayVcd(484)
        elseif sp_a1_wakeup_gantryexpositioncounter == 2 then
            sp_a1_wakeup_gantryexpositioncounter = sp_a1_wakeup_gantryexpositioncounter + 1
            GladosPlayVcd(485)
        elseif sp_a1_wakeup_gantryexpositioncounter == 3 then
            sp_a1_wakeup_gantryexpositioncounter = sp_a1_wakeup_gantryexpositioncounter + 1
            GladosPlayVcd(486)
        end
    end
end

function sp_a1_wakeup_gantry_door_open()
    GladosPlayVcd(487)
end

function sp_a1_wakeup_there_she_is()
		GladosPlayVcd(488)
end

function sp_a1_wakeup_human_exposition_end()
	sp_a1_wakeup_gantryexpositionend = true
end

function sp_a1_wakeup_down_the_stairs()
		GladosPlayVcd(489)
end

function sp_a1_wakeup_JumpNags()
	GladosPlayVcd(581)
end

function sp_a1_wakeup_Falling()
    nuke()
    GladosPlayVcd(579)
end

function sp_a1_wakeup_Landed()
	GladosPlayVcd(580)
end

function sp_a1_wakeup_come_through_here()
		if sp_a1_wakeup_Looked_Down then
			GladosPlayVcd(586)
		end
end

function sp_a1_wakeup_Do_Not_Look_Down()
		GladosPlayVcd(491)
end

function sp_a1_wakeup_Do_Not_Look_Down_Over()
	sp_a1_wakeup_Looked_Down = true
	EntFire("@ComeThroughHereTrigger","enable","",0.2)
end


function sp_a1_wakeup_This_Is_Breaker_Room()
		GladosPlayVcd(492)
end

function sp_a1_wakeup_Lets_Go_In()
		if not sp_a1_wakeup_In_Breaker_Room then
			GladosPlayVcd(585)
		end
end

function sp_a1_wakeup_Do_Not_Touch()
		sp_a1_wakeup_In_Breaker_Room = true
		GladosPlayVcd(493)
end

function sp_a1_wakeup_Lights_On()
		GladosPlayVcd(494)
end

function sp_a1_wakeup_Oops()
	GladosPlayVcd(542)
end

----------------------------------------------------------------------------------------------------------------
--Wheatley Elevator Scene (currently after sp_a2_column_blocker)
----------------------------------------------------------------------------------------------------------------


function Wheatley_Elevator_Scene_Start()
		GladosPlayVcd(495)
end

function Wheatley_Elevator_Scene_Ow()
		GladosPlayVcd(496)
end

----------------------------------------------------------------------------------------------------------------
--Jailbreak - sp_a2_bts1 & bts2
----------------------------------------------------------------------------------------------------------------

if curMapName == "sp_a2_bts1" then
	sp_a2_bts1_FakeEntered = false
end



function JailbreakGladosSomethingWrong()
	GladosPlayVcd(301)
end

function JailbreakWheatleyHeyLady()
	GladosPlayVcd(497)
end

function JailbreakICanHearYou()
	nuke()
	EntFire( "@sphere", "SetIdleSequence", "sphere_damaged_glance_concerned", 0 )
	GladosPlayVcd(498)
end

function JailbreakWheatleyCloseChamber()
	WheatleyStopNag()	
	GladosPlayVcd(500)
end

function WheatleyKeepMoving()
	--WheatleyStopNag()	
	--GladosPlayVcd(501)
end

function WheatleyGoGoGoNag()
	GladosPlayVcd(502)
end

function JailbreakLastTestIntro()
	WheatleyStopNag()	
	GladosPlayVcd(503)
end

function JailbreakLastChamberMain()
	WheatleyStopNag()	
	GladosPlayVcd(504)
end

function JailbreakLastTestDeer()
	sp_a2_bts1_FakeEntered = true
	WheatleyStopNag()	
	GladosPlayVcd(505)
end

function JailBreakHowStupid()
	if not sp_a2_bts1_FakeEntered then
		WheatleyStopNag()	
		GladosPlayVcd(506)
	end
end

function JailbreakBridgeDisappear()
	WheatleyStopNag()	
	GladosPlayVcd(507)
end

function JailbreakLookOutTurrets()
	WheatleyStopNag()	
	GladosPlayVcd(508)
end

function JailBreak2Trapped()
	WheatleyStopNag()	
	GladosPlayVcd(573)
end

function JailBreak2Gunfire()
	GladosPlayVcd(574)
end

function bts2_wheatley_comeon_prompt()
	GladosPlayVcd(587)
end

function JailBreak2AlmostOut()
	GladosPlayVcd(575)
end

function JailBreak2BringingDown()
	GladosPlayVcd(576)
end

function JailbreakHurryHurry()
	WheatleyStopNag()	
	GladosPlayVcd(509)
end

function JailbreakGetInTheLift()
	WheatleyStopNag()	
	GladosPlayVcd(510)
end

function jailbreak_player_in_exit_elevator()
	WheatleyStopNag()	
	GladosPlayVcd(511)
end

function Jailbreak2ThisWay()
	WheatleyStopNag()	
	GladosPlayVcd(512)
end

function JailbreakGoGo()
	WheatleyStopNag()	
	GladosPlayVcd(513)
end

function JailbreakComeOnComeOn()
	WheatleyStopNag()	
	GladosPlayVcd(514)
end


----------------------------------------------------------------------------------------------------------------
--Turret Factory -- sp_a2_bts4
----------------------------------------------------------------------------------------------------------------

if curMapName == "sp_a2_bts4" then
	sp_a2_bts4_StillThinkingNagStage = 0
	sp_a2_bts4_StillThinkingNagOK = false
	sp_a2_bts4_StillThinkingNagIdx = 0
	sp_a2_bts4_StillThinkingNagTime = 0
	sp_a2_bts4_MentionedSwap = false
	sp_a2_bts4_At_Window = false
	sp_a2_bts4_At_Big_Potato = false
	sp_a2_bts4_At_Volcano = false
	sp_a2_bts4_Intro_Talking = false
	sp_a2_bts4_Science_Fair_Busy = false
	sp_a2_bts4_Did_Big_Potato = false
	sp_a2_bts4_Did_Volcano = 0
end


function FactoryWheatleyHey()
	GladosPlayVcd(515)
end

function FactoryFollowMe()
	GladosPlayVcd(516)
end

function FactoryAlmostThere()
	GladosPlayVcd(518)
end


function FactoryTahDah()

	GladosPlayVcd(517)
end

function FactoryScannerIntro()
	sp_a2_bts4_At_Window = true
	if not sp_a2_bts4_Intro_Talking then
		GladosPlayVcd(519)
	end
end

function FactoryScannerSpeech()

	GladosPlayVcd(519)
end

function FactoryCheckAtWindowEnd()

	sp_a2_bts4_Intro_Talking = false
	if sp_a2_bts4_At_Window then
		FactoryScannerSpeech()
	end
end

function FactoryCheckAtWindowStart()
	sp_a2_bts4_Intro_Talking = true
	if sp_a2_bts4_At_Window then
		FactoryScannerSpeech()
	end
end


function FactoryControlDoorHackIntro()
	GladosPlayVcd(520)
end

function FactoryControlRoomHackSuccess()
	WheatleyStopNag()	
	GladosPlayVcd(521)
end

function FactoryFirstTurretTaken()
	WheatleyStopNag()	
	GladosPlayVcd(522)
end

function FactoryFirstTurretPulled()
	--WheatleyStopNag()	
	--GladosPlayVcd(522)
end


function FactoryEnableThinkingNag()
	print("%%%%%%%%%%%%%%%%ENABLE STILL THINKING NAG")
	sp_a2_bts4_StillThinkingNagOK = true
end

function FactoryDisableThinkingNag()
	print("%%%%%%%%%%%%%%%%DISABLE STILL THINKING NAG")
	sp_a2_bts4_StillThinkingNagOK = false
end

function FactoryStillThinkingNag()
    print("%%%%%%%%%%%%%%%%STILL THINKING NAG")

    if sp_a2_bts4_StillThinkingNagStage == 0 then
        if not sp_a2_bts4_StillThinkingNagOK then
            return
        end

        -- If Wheatley is not the current character in scene
        if characterCurscene("wheatley") ~= nil then
            sp_a2_bts4_StillThinkingNagTime = CurTime()
            return
        end

        -- Check time elapsed and make a random choice to proceed
        if CurTime() - sp_a2_bts4_StillThinkingNagTime > 5 and RandomInt(1, 100) > 50 then
            sp_a2_bts4_StillThinkingNagIdx = sp_a2_bts4_StillThinkingNagIdx + 1
            sp_a2_bts4_StillThinkingNagTime = CurTime()

            -- Play appropriate VCD based on the index
            if sp_a2_bts4_StillThinkingNagIdx == 1 then
                GladosPlayVcd(523)
            elseif sp_a2_bts4_StillThinkingNagIdx == 2 then
                GladosPlayVcd(524)
            elseif sp_a2_bts4_StillThinkingNagIdx == 3 then
                GladosPlayVcd(525)
            elseif sp_a2_bts4_StillThinkingNagIdx == 4 then
                GladosPlayVcd(526)
            elseif sp_a2_bts4_StillThinkingNagIdx == 5 then
                GladosPlayVcd(527)
            elseif sp_a2_bts4_StillThinkingNagIdx == 6 then
                GladosPlayVcd(528)
            elseif sp_a2_bts4_StillThinkingNagIdx == 7 then
                sp_a2_bts4_MentionedSwap = true
                GladosPlayVcd(529)
            elseif sp_a2_bts4_StillThinkingNagIdx == 8 then
                sp_a2_bts4_MentionedSwap = true
                GladosPlayVcd(530)
            else
                sp_a2_bts4_MentionedSwap = true
                GladosPlayVcd(531)
            end
        end
    elseif sp_a2_bts4_StillThinkingNagStage == 1 then
        -- Add any additional behavior for stage 1 here if needed
    end
end


function FactoryWhereAreYouGoing()
	if not sp_a2_bts4_MentionedSwap then
		GladosPlayVcd(532)
	end
end

function FactoryWhereAreYouGoingTwo()
	if not sp_a2_bts4_MentionedSwap then
		GladosPlayVcd(533)
	end
end


function FactoryBroughtBackDefectiveTurret()
	print("$$$$$$$$$$$$$CRAP TURRET TRIGGER")
	sp_a2_bts4_StillThinkingNagStage = 2
	if sp_a2_bts4_MentionedSwap then
		GladosPlayVcd(535)
	else
		GladosPlayVcd(534)
	end
end

function FactoryWheatleyShoutout()
	if not sp_a2_bts4_MentionedSwap then
		GladosPlayVcd(541)
	end
end

function FactoryEnterScannerRoomWithTurret()
	if not sp_a2_bts4_MentionedSwap then
		GladosPlayVcd(540)
	end
end

function FactorySuccess()
	sp_a2_bts4_StillThinkingNagStage = 2
	if sp_a2_bts4_MentionedSwap then
		GladosPlayVcd(539)
	else
		GladosPlayVcd(538)
	end
end


function ScienceFairBusy()
	sp_a2_bts4_Science_Fair_Busy = true
end

function ScienceFairNotBusy()
	sp_a2_bts4_Science_Fair_Busy = false
	if sp_a2_bts4_At_Volcano then
		PlayerNearScienceFairVolcano()
		return
	end
	if sp_a2_bts4_At_Big_Potato then
		PlayerLookingAtScienceFairPotato()
		return
	end
end


function PlayerNearScienceFairVolcano()
    sp_a2_bts4_At_Volcano = true

    if not sp_a2_bts4_Science_Fair_Busy then
        if sp_a2_bts4_Did_Volcano == 0 then
            sp_a2_bts4_Did_Volcano = 1
            GladosPlayVcd(583)
        elseif sp_a2_bts4_Did_Volcano == 1 then
            sp_a2_bts4_Did_Volcano = 2
            GladosPlayVcd(584)
        end
    end
end

function PlayerLeavingScienceFairVolcano()
	sp_a2_bts4_At_Volcano = false
end


function PlayerLookingAtScienceFairPotato() -- fires once player looks at potato plant
    sp_a2_bts4_At_Big_Potato = true

    if not sp_a2_bts4_Science_Fair_Busy then
        if not sp_a2_bts4_Did_Big_Potato then
            sp_a2_bts4_Did_Big_Potato = true
            GladosPlayVcd(582)
        end
    end
end


function PlayerNotLookingAtScienceFairPotato() -- fires if player looks away from plant after looking at it
		sp_a2_bts4_At_Big_Potato = false
end


----------------------------------------------------------------------------------------------------------------
-- BTS4 conveyor turret functions
----------------------------------------------------------------------------------------------------------------

-- ========================================================
-- Called when the player gets near the turret for the first time
-- ========================================================

if curMapName=="sp_a2_bts4" then
	sp_a2_bts4_redemption_turret_held = false
	sp_a2_bts4_redemption_turret_babble_index = 0
	sp_a2_bts4_redemption_turret_babbling = false
end


function SabotageFactoryRecycledTurretNoticesPlayer()
	GladosPlayVcd(439, nil, "conveyor_turret_body")
end


-- ========================================================
-- SP_A2_BTS4 ACHIEVEMENT - ACH.SAVE_REDEMPTION_TURRET
-- ========================================================
function bts4_redemption_line_turret_achievement()
	-- award achievement after turret is done speaking
	EntFire("achievement_redemption_line", "fireevent", 0, 0 )
end

-- ========================================================
-- Called every time the turret is picked up
-- ========================================================
function bts4_redemption_line_turret_pickup()
	sp_a2_bts4_redemption_turret_held = true
	if not sp_a2_bts4_redemption_turret_babbling then
		GladosPlayVcd(614, nil, "conveyor_turret_body")
	end
end

-- ========================================================
-- Called every time the turret is dropped
-- NOTE: when turret gets fizzled it is also dropped
-- so this function will get called
-- ========================================================
function bts4_redemption_line_turret_drop()
	sp_a2_bts4_redemption_turret_held = false
end

function bts4_redemption_line_turret_babble_start()
	sp_a2_bts4_redemption_turret_babbling = true
end

function bts4_redemption_line_turret_babble_end()
    local dly = math.random(2, 5)  -- Use math.random instead of RandomInt
    sp_a2_bts4_redemption_turret_babbling = false

    if sp_a2_bts4_redemption_turret_held then
        -- Using the EntityFire equivalent in Garry's Mod
        -- "EntFire" is not available in Garry's Mod directly, so we use `Entity:Fire` with appropriate arguments
        local glados = ents.FindByName("@glados")[1]
        if glados then
            glados:Fire("runscriptcode", "bts4_redemption_line_turret_babble()", nil, dly)
        end
    end
end


function bts4_redemption_line_turret_babble()
    if not sp_a2_bts4_redemption_turret_babbling then
        if sp_a2_bts4_redemption_turret_held then
            if sp_a2_bts4_redemption_turret_babble_index < 8 then
                sp_a2_bts4_redemption_turret_babble_index = sp_a2_bts4_redemption_turret_babble_index + 1
                GladosPlayVcd(614 + sp_a2_bts4_redemption_turret_babble_index, nil, "conveyor_turret_body")
            end
        end
    end
end


-- ========================================================
-- Called if turret is not saved and goes through conveyor exit
-- ========================================================
function bts4_redemption_line_turret_not_saved()
	GladosCharacterStopScene("conveyor_turret_body")
	GladosPlayVcd(613, nil, "conveyor_turret_body")
end

-- ========================================================
-- Called if player and turret are approaching the fizzler
-- NOTE: if the player leaves and comes back this could be triggered
-- again!
-- ========================================================
function bts4_redemption_line_fizzler_approach()
end

-- ========================================================
-- Called if turret gets fizzled
-- ========================================================
function bts4_redemption_line_turret_fizzled()	
	GladosCharacterStopScene("conveyor_turret_body")
	GladosPlayVcd(613, nil, "conveyor_turret_body")
end

-- ========================================================
-- Called when player gets into dummy shoot area
-- ========================================================
function bts4_redemption_line_turret_safe()
end



----------------------------------------------------------------------------------------------------------------
--Turret Factory -- sp_a2_intro - incinerator
----------------------------------------------------------------------------------------------------------------

function sp_a2_intro_SecondSpeech()
    if characterCurscene("glados") == nil then
        GladosPlayVcd(206)
    else
        GladosPlayVcd(543)
    end
end

function sp_a2_intro_ClearArms()
    if characterCurscene("glados") == nil then
        GladosPlayVcd(208)
    else
        GladosPlayVcd(544)
    end
end




----------------------------------------------------------------------------------------------------------------
--sp_a1_intro1
----------------------------------------------------------------------------------------------------------------

if curMapName == "sp_a1_intro1" then
	sp_a1_intro1_fizzler_triggered = false
	sp_a1_intro1_fizzler_said = false
	sp_a1_intro1_fizzler_passed = false
end

function sp_a1_intro1_fizzler_intro()
	sp_a1_intro1_fizzler_triggered = true
	if characterCurscene("glados") == nil then
		sp_a1_intro1_fizzler_said = true
		GladosPlayVcd(553)
	end
end

function sp_a1_intro1_fizzler_passed()
    if not sp_a1_intro1_fizzler_said then
        sp_a1_intro1_fizzler_passed = true
        if characterCurscene("glados") == nil then
            sp_a1_intro1_fizzler_said = true
            GladosPlayVcd(630)
        end
    end
end

function sp_a1_intro1_fizzler_test()
    if sp_a1_intro1_fizzler_triggered and not sp_a1_intro1_fizzler_said then
        sp_a1_intro1_fizzler_said = true
        if sp_a1_intro1_fizzler_passed then
            GladosPlayVcd(630)
        else
            GladosPlayVcd(553)
        end
    end
end

----------------------------------------------------------------------------------------------------------------
--sp_a1_intro3
----------------------------------------------------------------------------------------------------------------

--Triggers when you drop into the "Mind the Gap" puzzle
function sp_a1_intro3_turret_live_fire()
	GladosPlayVcd(623)
end


----------------------------------------------------------------------------------------------------------------
--sp_a1_intro6
----------------------------------------------------------------------------------------------------------------

function sp_a1_intro6_PuzzleOneCompleted()
	print("Insert puzzle 1 completed dialog here.")
end



----------------------------------------------------------------------------------------------------------------
--sp_a2_fizzler_training
----------------------------------------------------------------------------------------------------------------
function sp_a2_fizzler_training_Have_To_Go()
	GladosPlayVcd(546)
end

----------------------------------------------------------------------------------------------------------------
--sp_a4_turret_tbeam functions
----------------------------------------------------------------------------------------------------------------

function Finale02_turret_tbeam_abort1()
	GladosPlayVcd(556)
end

function Finale02_turret_tbeam_2()
	GladosPlayVcd(557)
end

function Finale02_turret_tbeam_abort2()
	GladosPlayVcd(558)
end

function Finale02_turret_tbeam_3()
	GladosPlayVcd(559)
end

function Finale02_turret_tbeam_abort3()
	GladosPlayVcd(560)
end

--stub function from co-op
function BotDeath(arg,arg2)
end

--sp_a1_intro6_first half of chamber
function MidpointPuzzleCompleted()
	GladosPlayVcd(626)
end



----------------------------------------------------------------------------------------------------------------
-- Control Potatos light
----------------------------------------------------------------------------------------------------------------

function PotatosTurnOff()
	GetPlayer().TurnOffPotatos();
end

function PotatosTurnOn()
	GetPlayer().TurnOnPotatos();
end


